function importUniqueContacts() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const contactsSheet = ss.getSheetByName("Contacts"); // Existing contacts sheet
    const newContactsSheet = ss.getSheetByName("New Contacts"); // Sheet with new contacts to import

    // Define the key field column (e.g., Full Name in Column 1)
    const keyFieldColumn = 1; // Column A
    const roleColumn = 4; // Column D with validation rules
    const checkboxColumnL = 12; // Column L
    const checkboxColumnN = 14; // Column N

    // Allowed roles in column D
    const validRoles = new Set(["1st AC", "2nd AC", "AC", "Creator", "Camera Operator", "Director", "DP", "N/A", "Producer", "Gaffer", "Key Grip", "Grip", "Electrician", "PA", "Sound Mixer", "1st AD", "DIT", "Drone Pilot", "BTS", "Utility", "Production Coordinator", "Loader", "Crane Operator", "Line Producer", "Script Supervisor", "Production Assistant", "UPM", "Carpenter", "Standby Scenic", "Editor", "AD", "Post Sound", "VTR", "Actor", "Costumer", "Set Medic","Costumer","Showrunner", "Screenwriter"]);

    // Log data retrieval
    Logger.log("Retrieving data from sheets...");

    // Get data from both sheets with error handling
    let contactsData, newContactsData;
    try {
      contactsData = contactsSheet.getDataRange().getValues();
      Logger.log(`Contacts sheet has ${contactsData.length} rows`);
    } catch (error) {
      Logger.log(`Error getting contacts data: ${error.message}`);
      SpreadsheetApp.getUi().alert(`Error getting contacts data: ${error.message}`);
      return;
    }
    
    try {
      newContactsData = newContactsSheet.getDataRange().getValues();
      Logger.log(`New Contacts sheet has ${newContactsData.length} rows`);
    } catch (error) {
      Logger.log(`Error getting new contacts data: ${error.message}`);
      SpreadsheetApp.getUi().alert(`Error getting new contacts data: ${error.message}`);
      return;
    }

    // Create a set of existing keys from the contacts sheet for quick lookup
    Logger.log("Creating existing keys set...");
    const existingKeys = new Set(contactsData.slice(1).map(row => row[keyFieldColumn - 1]));
    Logger.log(`Found ${existingKeys.size} existing contacts`);

    // Clear any previous red highlights in the Role column
    Logger.log("Clearing previous highlights...");
    newContactsSheet.getRange(2, roleColumn, newContactsData.length - 1).setBackground(null);

    // Array to store unique new contacts, only rows with non-empty key fields and valid roles
    const uniqueContacts = [];

    // Loop through new contacts and only add those that are not duplicates, have data, and valid roles
    Logger.log(`Processing ${newContactsData.length - 1} new contacts...`);
    for (let i = 1; i < newContactsData.length; i++) { // Skip header row
      if (i % 100 === 0) Logger.log(`Processing contact ${i} of ${newContactsData.length - 1}`);
      
      const newContact = newContactsData[i];
      const newContactKey = newContact[keyFieldColumn - 1];
      const role = newContact[roleColumn - 1];

      // Highlight cells in red if they have an invalid role
      if (!validRoles.has(role)) {
        newContactsSheet.getRange(i + 1, roleColumn).setBackground("red");
      }

      // Only add valid contacts to uniqueContacts array
      if (newContactKey && newContact.some(cell => cell !== "") && !existingKeys.has(newContactKey) && validRoles.has(role)) {
        uniqueContacts.push(newContact);
        existingKeys.add(newContactKey); // Add to the set to avoid duplicates in this batch
      }
    }
    Logger.log(`Found ${uniqueContacts.length} unique contacts to add`);

    // Append unique contacts to the Contacts sheet
    if (uniqueContacts.length > 0) {
      // Add new contacts to the Contacts sheet at the end
      const startRow = contactsSheet.getLastRow() + 1;
      contactsSheet.getRange(startRow, 1, uniqueContacts.length, uniqueContacts[0].length).setValues(uniqueContacts);

      // Set column L (checkboxColumnL) to TRUE for all newly added contacts and turn them into checkboxes
      const rangeL = contactsSheet.getRange(startRow, checkboxColumnL, uniqueContacts.length, 1); // Column L
      rangeL.setValue(true); // Set the cell to TRUE
      rangeL.insertCheckboxes(); // Convert the cells to checkboxes

      // Set column N (checkboxColumnN) to TRUE for all newly added contacts and turn them into checkboxes
      const rangeN = contactsSheet.getRange(startRow, checkboxColumnN, uniqueContacts.length, 1); // Column N
      rangeN.setValue(true); // Set the cell to TRUE
      rangeN.insertCheckboxes(); // Convert the cells to checkboxes
    }

    // Check column N checkbox for matching names between New Contacts and existing Contacts
    Logger.log("Processing matching contacts for column N checkboxes...");
    
    // Get only column A (Full Name) from both sheets for efficient matching
    Logger.log("Retrieving column A data...");
    const existingNames = contactsSheet.getRange(2, 1, contactsSheet.getLastRow() - 1, 1).getValues().flat();
    const newContactNames = newContactsSheet.getRange(2, 1, newContactsSheet.getLastRow() - 1, 1).getValues().flat();
    
    Logger.log(`Checking for matches among ${existingNames.length} existing contacts`);
    
    let matchesFound = 0;
    const rowsToUpdate = [];
    
    // Find matching names and collect rows to update
    Logger.log("Finding matches...");
    for (let i = 0; i < newContactNames.length; i++) {
      if (i % 50 === 0) Logger.log(`Checking match ${i} of ${newContactNames.length}`);
      
      const newContactName = newContactNames[i];
      
      if (existingNames.includes(newContactName)) {
        // Find the row in Contacts sheet where this name exists
        const rowIndex = existingNames.indexOf(newContactName) + 2; // +2 because we started from row 2 and arrays are 0-indexed
        rowsToUpdate.push(rowIndex);
        matchesFound++;
      }
    }
    
    Logger.log(`Found ${matchesFound} matches. Updating checkboxes...`);
    
    // Batch update the checkboxes
    if (rowsToUpdate.length > 0) {
      // Update in batches of 50 to avoid timeouts
      const batchSize = 50;
      for (let i = 0; i < rowsToUpdate.length; i += batchSize) {
        const batch = rowsToUpdate.slice(i, i + batchSize);
        Logger.log(`Updating batch ${Math.floor(i/batchSize) + 1} of ${Math.ceil(rowsToUpdate.length/batchSize)}`);
        
        batch.forEach(rowIndex => {
          contactsSheet.getRange(rowIndex, checkboxColumnN).setValue(true);
          contactsSheet.getRange(rowIndex, checkboxColumnN).insertCheckboxes();
        });
      }
    }
    
    Logger.log(`Updated ${matchesFound} existing contacts with column N checkboxes`);

    // Sort contacts in the Contacts sheet alphabetically by Full Name (column A) from row 4 onwards
    const totalRows = contactsSheet.getLastRow();
    if (totalRows > 3) { // Ensure there is data to sort starting from row 4
      const rangeToSort = contactsSheet.getRange(4, 1, totalRows - 3, contactsSheet.getLastColumn()); // Start from row 4
      rangeToSort.sort([{ column: keyFieldColumn, ascending: true }]); // Sort by Full Name in column 1
    }

    // Display an alert for the number of contacts added
    SpreadsheetApp.getUi().alert(`${uniqueContacts.length} unique contacts added and sorted alphabetically.`);
  } catch (error) {
    Logger.log(`Error: ${error.message}`);
    SpreadsheetApp.getUi().alert(`An error occurred: ${error.message}`);
  }
}
